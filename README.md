# Problem Solving Made Functional - F#

FAQ
============

Why should we practice problem solving?
============

Problems solving is a **must** skill to have for a software developer, we can't get the job done if we aren't able to solve problems through the use of software. Problems can occur in many flavours such as:

* Algorithm design
* System design
* Picking an implementation design
* Choosing the right data structure for your problem space
* Getting rid of your pesky bug

(You get the idea, there are many different kind of problems in our day-to-day work).

This repository should be seen as a dojo to help sharpen your problem solving skills to make you an even better developer than you are currently. Work skills are more useful when they actually help your career. Drawing, sports and music are all more fun when youâ€™re good at them. Same thing goes for software development: putting some time aside for you to get better will pay dividends in the long run. You'll be able to use the Jupyter Notebooks for your self and make them grow with time if you feel the need for it.


What are the area(s) of focus of this repository?
============
A gentle guide for software developers in problem solving, functional programming or getting back the fundamentals of software engineering and computer science. This guide leverages the latest and newest version of .NET Core (.NET Core 3.1 at the time of writing - F# 4.7). This repository will focus on the following elements: 

* Functional Programming with F#
* [Coding Katas](http://codekata.com/)
* Coding Interview Questions
* Designing Software Systems with implementations
* Analyzing Big-O (time & space complexities)
* Picking a solution 

Why functional programming and F# for problem solving? 
============

Functional programming isn't something that's new; it's a pretty old concept that's becoming more and more present in the industry nowadays. There are many reasons that explain why that is such as:

* Provides great productivity - produces shorter programs in a quicker time
* You have complete power over your mutation (immutability)
* Pure functions are easy to reason with and will always provide the same output with the same input
* It gives you a new tool to work with and a new perspective on **problem solving**
* .NET Core is a great platform for development and there's a lot of active development in .NET for entreprise projects

For the curious, here are a few posts on why F# is a great tool to have in your toolbox.

* [Why F# - Code Magazine](https://www.codemag.com/article/1605061)
* [6 Reasons Why F# Might Be The Coolest Language You've Never Heard Of](https://mislavjavor.github.io/2017-05-30/6-Reasons-Why-F-Might-Be-The-Coolest-Language-You%27ve-Never-Heard-Of/)
* [Why F# is the best enterprise language](https://fsharpforfunandprofit.com/posts/fsharp-is-the-best-enterprise-language/)
* [Why use F# when your team uses C#](https://kevinavignon.com/2019/09/23/why-should-you-use-f-when-your-team-uses-c/)


Where will the problems to solve come from?
==============
There are a lot of free material online, and this repository will try to centralize some of them. To make sure it doesn't get bigger than it needs to be, we'll keep it lean whenever it's possible. We don't need multiple instances of the same kind of problems that are solved with an hashma if they are **similar**.

The material will come from resouces such as:

* [System Design Primer](https://github.com/donnemartin/system-design-primer)
* [Design of Computer Programs](https://www.udacity.com/course/design-of-computer-programs--cs212)
* [Interactive Coding Challenges](https://github.com/donnemartin/interactive-coding-challenges)
* [The Algorithm design manual](http://www.algorist.com/)
* [Hacker Rank](https://www.hackerrank.com/) 
* [CodeWars](https://www.codewars.com)
* [Project Euler](https://projecteuler.net/archives)

Recommended resources to improve?
=============

* [Introduction to Algorithms](https://www.amazon.ca/Introduction-Algorithms-Thomas-H-Cormen/dp/0262033844)
* [The Algorithm Design Manual](https://www.amazon.ca/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693/ref=sr_1_1?keywords=the+algorithm+design+manual&qid=1575915958&sr=8-1)
* [Composing Software](https://leanpub.com/composingsoftware)
* [Design of Computer Programs](https://www.udacity.com/course/design-of-computer-programs--cs212)
* [Data Structures and Algorithms Specialization](https://www.coursera.org/specializations/data-structures-algorithms)


How can I contribute to the repo?
==============
If you find there a grammar mistake, an implementation problem (poor design decision, something unclear, something incorrect in the implementation) or simply something new that you feel the repository is missing, do not hesitate to clone the repository, create an issue and open a PR. I accept every contribution! There are no such thing as a too small contribution. Every single bit matters :)

Are there any similar resources?
==============

* https://github.com/aforarup/interview
* https://github.com/schmatz/cs-interview-guide
* https://github.com/SITZ/JobPuzzles
* https://github.com/alex/what-happens-when
